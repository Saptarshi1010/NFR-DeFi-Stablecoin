// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";
import {Vm} from "forge-std/Vm.sol";
import {StdCheats} from "forge-std/StdCheats.sol";
import {ExploitContract} from "../../src/challenge/ExploitContract.sol";
import {LessonTwelveHelper} from "../../src/challenge/LessonTwelveHelper.sol";

contract ExploitFinder is StdCheats, Test {
    address private constant TARGET = 0x5Cbd7Feb522f3060985Ddb07929eB7ee12568a48;
    address private constant HUNTED = 0xe5760847db2f10A74Fc575B4803df5fe129811C1;
    address private constant HACKER = 0x50e2a33B9E04e78bF1F1d1F94b0be95Be63C23e7;

    uint256 deployerKey = vm.envUint("PRIVATE_KEY");

    LessonTwelveHelper private helper;

    function setUp() external {
        vm.startPrank(HACKER);

        helper = new LessonTwelveHelper();

        vm.stopPrank();
    }

    /** @dev Naming below `testFail` is telling foundry we expect it to fail and if it will fail test pass */
    function testFailExploit(uint128 randomNumber) public {
        vm.startPrank(HACKER);

        /** @dev Brute Forcing All Solutions As Hitting Correct Random Number Value Is Pretty Hard */
        /** @dev Below Function Will Fail For Correct Random Number Value */
        for (randomNumber = 0; randomNumber < 2 ** 128 - 1; randomNumber++) {
            /** @dev Below is excluding certain cases */
            vm.assume(helper.hellFunc(randomNumber) < 2 ** 128 - 1);
            /** @dev We can also increase tests amount in `foundry.toml` */
            helper.hellFunc(randomNumber);
        }

        /** @dev Other Solution */
        // for (randomNumber = 0; randomNumber < 2 ** 128 - 1; randomNumber++) {
        //     (bool success, ) = address(helper).call(abi.encodeWithSignature("hellFunc(uint128)", randomNumber));
        //     if (success) {
        //         console.log("Number Not Found...");
        //     } else {
        //         console.log("Number Found!: ", randomNumber);
        //         break;
        //     }
        // }

        vm.stopPrank();
    }

    function isUint256(uint256 number) public pure returns (bool) {
        if (type(uint256).max >= number) {
            return true;
        } else {
            return false;
        }
    }

    function testFindNumber(uint128 randomNumber) external {
        vm.startPrank(HUNTED);

        /** @dev We would need to make it fail to get correct number */
        (bool success, ) = TARGET.call(abi.encodeWithSignature("hellFunc(uint128)", randomNumber));
        if (success) {
            console.log("Number Not Found...");
        } else {
            console.log("Number Found!: ", randomNumber);
        }

        /** @dev Getting number from bytes */
        // uint128 numberr = abi.decode(numberrBytes, (uint128));

        /** @dev Our return needs to exceed below */
        // uint256 targetNum = 115792089237316195423570985008687907853269984665640564039457584007913129639935; // 2**256 - 1

        vm.stopPrank();
    }
}
